---
title: "Time Series with R"
author: "Sara Geremia"
date: "2024-05-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, 
                      error = FALSE, message = FALSE)

```

Let's work with dates and times in R.

# Time Series

A time series is a sequence of data in chronological order. It is very common for any type of data to be recorded sequentially, or over time. And we find time series data everywhere, and especially in Financial and Economic applications. Examples include: monthly values of the House Price Index.


We will focus on the `lubridate` package, which makes it easy to work with dates and times in R.

```{r}
library(tidyverse)
library(lubridate)
```

## Create dates/times

You should always use the simplest possible data type that works for your needs:
avoid date-time data type if not necessary.
Date-times are substantially more complicated because of the need to handle time zones.

To get the current date or date-time you can use `today()` or `now()`:

```{r}
today()

now()
```

Date/time data often comes as strings. 
Identify the order in which year, month, and day appear in your dates, then use the 
appropriate functions:

```{r}
ymd("2024-05-24")
mdy("May 24th, 2024")
dmy("24-May-2024")
```

These functions also take unquoted numbers. 

```{r}
ymd(20240524)
```

Sometimes youâ€™ll have the individual components of the date-time spread across multiple columns:

```{r}
# load data
# install.packages("nycflights13")
library(nycflights13)
```


```{r}
# Sys.setlocale("LC_ALL", "en_US")

flights <- flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(dep_time = make_datetime(year, month, day, hour, minute))
  
```

## Visualize dates/times

The most common first step when conducting time series analysis is to display your time series dataset in a visually intuitive format. 

The defining feature is that time is indexed on the horizontal axis, and the observations are shown from the first, on the left, to the last, on the right. A line is commonly added to connect neighboring observations, to improve interpretability and to emphasize any trends or patterns.

```{r}
flights %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

```{r}
flights %>% 
  filter(dep_time < ymd("2013-01-02")) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

We can use wday() to see that more flights depart during the week than on the weekend:

```{r}
flights %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

Some time series data is exactly evenly spaced.
Some time series data is only approximately evenly spaced. 

The analysis of time series data proceeds with some simplifying assumptions: The first assumption is that consecutive observations are equally spaced. Secondly, a discrete-time observation index is applied. In practice, this may only hold approximately, and sometimes data may be missing. For example, daily log returns on a stock may only be available for weekdays, and data may not be available for certain holidays. Monthly House Price Index values are equally spaced by month, but not by days.

Sometimes there are missing values in time series data, denoted NA in R, and it is useful to know their locations. It is also important to know how missing values are handled by various R functions. Sometimes we may want to ignore any missingness, but other times we may wish to impute or estimate the missing values.

The mean() function calculates the sample mean, but it fails in the presence of any NA values. Use mean(___, na.rm = TRUE) to calculate the mean with all missing values removed. It is common to replace missing values with the mean of the observed values. 

```{r}

flights_dt <- flights %>% 
  count(year, month, day) %>% 
  mutate(dep_time = make_date(year, month, day)) %>% 
  filter(dep_time < ymd("2014-01-01"))


flights_dt_na <- flights_dt
flights_dt_na$n[flights_dt_na$dep_time > ymd("2013-01-31") & flights_dt_na$dep_time < ymd("2013-02-28")] <- mean(flights_dt_na$n, na.rm = TRUE)


```

```{r}
ggplot() +
  geom_line(data = flights_dt, aes(x = dep_time, y = n), color = "red", linetype = "dotted")+
  geom_line(data = flights_dt_na, aes(x = dep_time, y = n)) 
```

 Does this simple data imputation scheme appear adequate?
 
 Based on your plot, it seems that simple data imputation using the mean is not a great method to approximate what's really going on in the flights data.
 

## Create Time Series

 
Given a vector of numbers you can apply the ts() function to create a time series object. Such objects are of the `ts` class. They represent data that is at least approximately evenly spaced over time.
 
```{r}
data_vector <- c(10, 6, 11, 8, 10, 3, 6, 9)
print(data_vector)
plot(data_vector)

```

```{r}
time_series <- ts(data_vector)
```


When you plot the result using the plot() function the time index and label is automatically added to the horizontal axis. By default, R uses a simple observation index starting from 1 as the time index.

```{r}
print(time_series)
plot(time_series)
```

If you want the time series to start in the year 2001 with 1 observation per year you should apply the ts() function with the additional arguments start = 2001 and frequency = 1 as shown. Now when you plot the result you can see an updated time axis, running from 2001 through 2008.

```{r}
time_series <- ts(data_vector, start = 2001, frequency = 1)
plot(time_series)
```

A time series object is a vector (univariate) or matrix (multivariate) with additional attributes, including time indices for each observation, the sampling frequency and time increment between observations, and the cycle length for periodic data. 

The advantage of creating and working with time series objects of the ts class is that many methods are available for utilizing time series attributes, such as time index information.

Let's consider the eu_stocks dataset (available in R by default as EuStockMarkets). This dataset contains daily closing prices of major European stock indices from 1991-1998, specifically, from Germany (DAX), Switzerland (SMI), France (CAC), and the UK (FTSE). The data were observed when the markets were open, so there are no observations on weekends and holidays. We will proceed with the approximation that this dataset has evenly spaced observations and is a four dimensional time series.

 
```{r}
library(datasets)
data(EuStockMarkets)

```

```{r}
# Check whether EuStockMarkets is a ts object
is.ts(EuStockMarkets)

# View the start, end, and frequency of EuStockMarkets
start(EuStockMarkets)
end(EuStockMarkets)
frequency(EuStockMarkets)



# Generate a simple plot of EuStockMarkets
plot(EuStockMarkets)

# Use ts.plot with EuStockMarkets
ts.plot(EuStockMarkets, col = 1:4, xlab = "Year", ylab = "Index Value", main = "Major European Stock Indices, 1991-1998")

# Add a legend to your ts.plot
legend("topleft", colnames(EuStockMarkets), lty = 1, col = 1:4, bty = "n")

```

Let's try to make a better visualization.

```{r}
library(forecast)
autoplot(EuStockMarkets) + 
  theme_minimal()
```



